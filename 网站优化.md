## 	前端优化

 1. 减少http请求数
    
    a.  合并图片
    b.  css/js写到页面中
    c.  使用浏览器的缓存
         header('Cache-Control:max-age=1200');

 2. 使用CDN加速
 3. 压缩html/css/js等代码
 4. css写到页面开始部分，js写到页面尾部
 5. 减少cookie大小


## MySQL优化
  
  MySQL优化需要从以下几个角度优化：

  1、硬件
  2、软件层面： a.建表需要优化  b. SQL语句优化    c. MySQL配置参数的优化
  3、架构层面：a. 搭建主从数据库  b.分布式数据库



## 建表
  
   1.  建表一般尽量遵守数据库设计三范式，避免数据冗余
   2.  建表可以适度地反三范式，达到以空间换取时间
   3.  把一些不常用字段划分到其他表中，减小表大小(垂直分表)
   4.  把字段类型比较大划分到其他表中
   5.  一般能选择数字类型，就尽量选择数字类型
   6.  选择合适字段类型，一般保小去大



## 字段类型

    1.  数字类型

         tinyint  
    
           一个tinyint占用1个字节，表示范围:如果是无符号是0-255,有符号：-128到127

        

         int 

          int占用4个字节，表示范围：如果是无符号是0-42亿,

         bigint

          bigint占用8个字节，表示范围很大


    2.  字符串类型   

         char
		
			定长的，效率一般认为比varchar快。char(n),n表示n个字符。 

            char(1) 只能存放一个字符 

   

         varchar


			不定长的，需要一个字符表示大小,varchar(n)，n表示也是字符数,代表插入的字符数小于等于n，  n可以大于255

  

     
*** 字节与字符的关系

> 如果是utf8字符集，因为utf8存放中文占用三个字节大小，所以存放两个中文需要6个字节大小。

一个英语字母无论什么情况下都是占用一个字节的，所以varchar(6)就可以存放github这个英语单词了
 

*** tinyint(1)与tinyint(4)区别

   一般认为这两者是没有区别的，因为tinyint(1)与tinyint(4)占用的字节是一样，表示的范围还是一样。 

* int(1)与int(4)区别
   一般认为这两者是没有区别的，因为int(1)与int(4)占用的字节是一样，表示的范围还是一样。 
   


### 日期类型

	date
	
	date三个字节，如2015-05-01只能存储到天数。date精确到年月日（如：生日）
	
	time
	
	time三个字节,只能存小时分钟，time精确到小时分钟秒
	
	datetime
	
	datetime八字节，可以存储年月日时分秒
	
	timestamp
	
	timestamp四字节，可以存储年月日时分秒。如果没有给timestamp插入值，就默认是当前时间戳


# 表引擎

* innodb
* myisam
	BDB
	CSV


* innodb与myisam区别

  1.  是否支持事务
  innodb支持事务
       
  2.  锁机制不一样
  innodb支持行锁、表锁。 myisam支持表锁


  3.  数据与索引保存方式

   myisam产生三个文件，.MYD存放数据，.MYI存放索引。

   innodb数据与索引存放到一个文件中。


* 如何选择表引擎

  如果写操作频繁，必须选择innodb。原因：因为innodb支持的行锁。

  如果是读操作频繁，如果mysql版本是5.6以上，建议选择innodb,如果mysql版本是5.6之前，建议选择myisam




读操作会产生读锁（共享锁），写操作会产生写锁（排他锁）

共享锁不会阻塞(挡住)其他的读，会阻塞写操作。

排他锁(写锁)会阻塞读操作，也会阻塞写操作。




 



## 锁机制

  1. 表锁、行锁。 写锁（排他锁），读锁（共享锁）
 

  对数据：读、写，只要是读都会产生读锁。 读锁的影响范围可能是整个表，表锁。   

  读锁的影响范围是某行，行锁。 

   写操作，只要是写操作都会产生写锁(排他锁)，写锁的影响范围可能是某行，行锁。 



  2. 写锁特点： 写锁阻塞写、读
  3. 读锁特点：读锁阻塞写，不会阻塞读
  4. InnoDB存储引擎是通过索引上的索引项加锁来实现的，这就意味着：只有通过索引操作数据，InnoDB才会使用行锁。否则，InnoDB将使用表锁。



表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。    
行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。    
页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般   

InnoDB的行销是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。


  商品表（  innodb 行锁，表锁 ） 生成订单（事务，减少商品表的库存。  ）

 


